# Casbah

## Setup connection

In order to have a preconfigured REPL, I've created an SBT project (`demo`).
`demo/build.sbt`: the dependencies are listed here, as well as all project classes, are put in the REPL's classpath.

`repl.scala`: I've prepared this to avoid typing everything in the console, I'll uncomment the lines progressively and reload it.
First 3 lines: import Casbah types and create a connection to a `test` database.

    sbt console
    :l repl.scala

(NB: SLF4J raises a warning because no appender is configured; for our console session this does not matter)

Try to access the database:

    db.collectionNames

Which fails since MongoDB server is stopped. Do it now (NB: I start with an empty database):

    mongod

Now the command returns an empty set.

## Create a first document from Scala

    val s2 = MongoDBObject("brand" -> "Samsung", "model" -> "Galaxy SII", "price" -> 530)
    db("geektoys").save(s2)
    
    // NB: driver has set the id:
    s2
    
    // And we now have some collections in the database:
    db.collectionNames

## Check the result in Mongo

In a new console:

    mongo
    use test
    db.geektoys.find()

## The other way around: insert from Mongo and load in Scala

In Mongo console:

    db.geektoys.save( { brand: "Apple", model: "iPhone 4S", price: NumberInt(630) } )

(NB: in Javascript, numbers are floats by default, we need to explicitely ask for an integer.)

And check in Scala console (btw, this also demonstrates how to perform a query):

    val dbo = db("geektoys").findOne("price" $gt 600).next

## Access object properties:

    dbo.get("model")
    dbo.get("price")
    
    // NB: result is not typed. To force conversion:
    dbo.as[String]("model")
    dbo.as[Int]("price")
    
    // of course we get a failure if we specify the wrong type:
    dbo.as[String]("price")
    
    // and also with a property name that does not exist:
    dbo.as[String]("color")
    
    // however, we can handle optional properties:
    dbo.getAs[String]("model")
    dbo.getAs[String]("color")

In Scala, we'll probably want stronger typing, by mapping the documents to some Scala types.

The first option is to map to case classes, using Salat.

# Salat

## The model

Gotchas:

* Salat won't work with classes defined in the Scala REPL (due to the fact that it uses Scala pickled signatures - type information stored in the bytecode to avoid the cost of reflexion,
  somewhat similar to paranamer).
* it doesn't work with the default package either.

As a workaround, I've defined the classes in a source file in my project.

[`SalatModel.scala`] show and explain class structure, in particular `Option` and default value for `_id` (ignore commented parts for now).

[`repl.scala`] uncomment Salat and model classes import.

## From DB objects to case classes

[repl] try mapping the object that we previously loaded from the database:

    :l repl.scala
    
    dbo
    val iphone = grater[GeekToy].asObject(dbo)
    iphone.brand
    iphone.price

And creating a new class instance and serializing it:

    val nexus = GeekToy("Samsung", "Galaxy Nexus", 600)
    // NB: having _id with a default value is handy to create not-yet persisted instances

## From case classes to DB objects

Now try to go the other way - case class to DB object:

    grater[GeekToy].asDBObject(nexus)

Before we save the object to the database, there is a small detail we need to fix.

*Q*: do you notice anything in particular in the output?
*A*: Salat has added a `typeHint` field to the object. This is the default behavior, but in fact the type hint is only necessary when:
* using subcollections typed to a trait or abstract superclass
* looking up a `grater` from a `DBObject` (not a type)

We will change the configuration to use hints only when necessary.

[`repl.scala`] comment `salat.global._` import and uncomment custom context.

Now the previous example doesn't produce an extra property. Let's save the object.

## Saving

[`repl.scala`] uncomment `save` method and explain it. NB: case classes are immutable, which will probably lead to a more functional design

    val nexus2 = save(nexus)
    // returns a copy with the id set - nexus2 maps the persisted object
    
    // To change the price, make a copy and save it.
    val nexus3 = nexus2.copy(price = 550)
    // Since the id is set, MongoDB will update the existing record.
    save(nexus3)
    
    // Show that we have three different objects corresponding to the successive states:
    nexus
    nexus2
    nexus3

## Subdocuments

[`SalatModel.scala`] uncomment reviews property and corresponding case class.

[repl]

    :q
    sbt console
    :l repl.scala
    val ipad = val ipad = GeekToy("Apple", "iPad 3", 800, List(Review("Olivier", "Will it blend?")))
    save(ipad)

Check in Mongo => OK

## Mapping query results

To conclude, we'll load all the objects created so far and convert them to case classes:

    db("geektoys").find().toSeq.map(grater[GeekToy].asObject(_)).mkString("\n")

But this fails.

*Q*: do you see why?
*A*: we have some documents without a `reviews` property in the database.

[`SalatModel.scala`] add a default value of `List()` for `reviews` (I also tried changing the type to `Option[List[Review]]`, but then Salat would deserialize to plain DB objects).

