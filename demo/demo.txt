# Casbah

In order to have a preconfigured REPL, I've created an SBT project (`demo`).
Show `demo/build.sbt`: the dependencies listed here, as well as all project classes, are put in the REPL's classpath.

To avoid typing everything in the console, I've prepared a `repl.scala` file that I'll uncomment and reload progressively.
First 3 lines: import Casbah types and create a connection to a `test` database.

    sbt console
    :l repl.scala

(NB: SLF4J raises a warning because no appender is configured; for our console session this does not matter)

Try to access the database:

    db.collectionNames

Which fails since MongoDB server is stopped. Do it now (NB: I start with an empty database):

    mongod

Now the command returns an empty set.

Create an object and insert it in a collection:

    val s2 = MongoDBObject("brand" -> "Samsung", "model" -> "Galaxy SII", "price" -> 530)
    db("geektoys").save(s2)
    
    // NB: driver has set the id:
    s2
    
    // And we now have some collections in the database:
    db.collectionNames

In a new console, open a MongoDB console to check the result:

    mongo
    use test
    db.geektoys.find()

We can also go the other way - insert from Mongo console:

    db.geektoys.save( { brand: "Apple", model: "iPhone 4S", price: NumberInt(630) } )

And check in Scala console (btw, this also demonstrates how to perform a query):

    db("geektoys").findOne(MongoDBObject("brand" -> "Apple"))
    
    // NB: the query returns an Option. In this particular case, we know that the value
    // is not None, so we can get the object directly:
    val dbo = db("geektoys").findOne(MongoDBObject("brand" -> "Apple")).get

Access object properties:

    iPhone.get("model")
    iPhone.get("price")
    
    // NB: result is not typed (AnyRef). To force conversion:
    iPhone.as[Int]("price")
    
    // or:
    iPhone.getAs[Int]("price")
    iPhone.getAs[Int]("weight")

Casbah also has a DSL for "fluid querying":

    db("geektoys").findOne("brand" $ne "Apple")

`MongoDBObject` is not very strongly typed (as a matter of fact, it extends `Map[String, AnyRef]`).
Using a static language like Scala, we probably want to map MongoDB data to our own custom types.

# Salat

Salat maps `DBObject`s to Scala case classes.

Gotchas:
* Salat won't work with classes defined in the Scala REPL (due to the fact that it uses Scala pickled signatures - type information stored in the bytecode, similar to paranamer).
* it doesn't work either with classes in the default package.

As a workaround, I've defined the classes in `src/main/scala/examples/SalatModel.scala` (all project classes end up in `sbt console`'s classpath).  (I import the package in the initialization commands).

In the Scala console, we can try deserializing a db object:

    grater[GeekToy].asObject(s2)

And creating a new class instance and serializing it:

    val nexus = GeekToy("Samsung", "Galaxy Nexus", 550)
    grater[GeekToy].asDBObject(nexus)
    // NB: we just exercize the serialization mechanism, nothing saved yet

In the example above, we notice that Salat has added a `typeHint` field to the object. This is the default behavior, but in fact the type hint is only necessary when:
* using subcollections typed to a trait or abstract superclass
* looking up a `grater` from a `DBObject` (not a type)

We can change the configuration to use hints only when necessary, by changing `build.sbt` like so:

    //import com.novus.salat.global._
    implicit val ctx = new Context {
      val name = "Custom Context"
      override val typeHintStrategy = StringTypeHintStrategy(when = TypeHintFrequency.WhenNecessary)
    }

Now the previous example doesn't produce an extra property.

NB: case classes are immutable, which will probably lead to a more functional design
(show and explain `save` method defined in SalatModel.scala).

    val nexus2 = save(nexus)
    // returns a copy with the id set - nexus2 maps the persisted object
    
    // To change the price, make a copy and save it.
    val nexus3 = nexus2.copy(price = 500)
    // Since the id is set, MongoDB will update the existing record.
    save(nexus3)
    
    // Show that we have three different objects corresponding to the successive states:
    nexus
    nexus2
    nexus3


TODO:
* nested classes (product reviews)
* query + map to case class
